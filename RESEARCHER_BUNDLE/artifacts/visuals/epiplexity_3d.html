<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Epiplexity 3D Proof Map</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: ui-sans-serif, system-ui, -apple-system, sans-serif;
      background: #0b0f14;
      color: #e6eef7;
      overflow: hidden;
    }
    #container { width: 100vw; height: 100vh; position: relative; }
    #canvas { width: 100%; height: 100%; }
    #controls {
      position: absolute;
      top: 16px;
      left: 16px;
      background: rgba(15, 23, 33, 0.95);
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #1c2a3a;
      max-width: 280px;
      z-index: 10;
    }
    #controls h1 { font-size: 1rem; margin-bottom: 8px; }
    #search {
      width: 100%;
      padding: 8px;
      background: #1a2633;
      border: 1px solid #2a3a4a;
      border-radius: 4px;
      color: #e6eef7;
      font-size: 0.9rem;
      margin-bottom: 8px;
    }
    #search:focus { outline: none; border-color: #4a9eff; }
    .control-row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }
    .control-btn {
      flex: 1;
      padding: 6px 10px;
      background: #1a2633;
      border: 1px solid #2a3a4a;
      border-radius: 4px;
      color: #e6eef7;
      font-size: 0.8rem;
      cursor: pointer;
    }
    .control-btn:hover { background: #2a3a4a; }
    .control-btn.active { background: #4a9eff; color: #0b0f14; }
    #legend {
      max-height: 250px;
      overflow-y: auto;
      font-size: 0.85rem;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
      cursor: pointer;
    }
    .legend-item:hover { background: #1a2633; }
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      flex-shrink: 0;
    }
    #tooltip {
      position: absolute;
      background: rgba(15, 23, 33, 0.95);
      padding: 8px 12px;
      border-radius: 4px;
      border: 1px solid #1c2a3a;
      font-size: 0.85rem;
      pointer-events: none;
      display: none;
      z-index: 100;
    }
    #tooltip .name { color: #4a9eff; font-weight: 500; }
    #tooltip .kind { color: #6b7d8c; }
    #instructions {
      position: absolute;
      bottom: 16px;
      left: 16px;
      background: rgba(15, 23, 33, 0.9);
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #1c2a3a;
      font-size: 0.8rem;
      color: #6b7d8c;
    }
    #instructions strong { color: #e6eef7; }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="canvas"></canvas>
    <div id="controls">
      <h1>Epiplexity 3D Proof Map</h1>
      <input type="text" id="search" placeholder="Search declarations...">
      <div class="control-row">
        <button class="control-btn" id="autoRotate">Auto-Rotate</button>
        <button class="control-btn" id="resetView">Reset View</button>
      </div>
      <div id="legend"></div>
    </div>
    <div id="tooltip"></div>
    <div id="instructions">
      <strong>Controls:</strong> Drag to rotate | Scroll to zoom | Click nodes for details
    </div>
  </div>

  <script src="epiplexity_proofs_data.js"></script>
  <script>
    const data = epiplexityProofsData;
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');
    const search = document.getElementById('search');
    const legend = document.getElementById('legend');
    const autoRotateBtn = document.getElementById('autoRotate');
    const resetViewBtn = document.getElementById('resetView');

    // 3D state
    let rotationX = 0.3;
    let rotationY = 0.5;
    let scale = 1;
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let autoRotating = true;
    let highlightFamily = null;
    let searchTerm = '';
    let selectedNode = null;

    const colors = {
      'Core': '#5e9cff',
      'MDL': '#c77dff',
      'Information': '#4ade80',
      'Bounds': '#fbbf24',
      'Conditional': '#22d3d3',
      'Programs': '#f472b6',
      'Emergence': '#fb923c',
      'Prelude': '#a3a3a3',
      'Crypto/Axioms': '#ef4444',
      'Crypto/CSPRNG': '#eab308',
      'Crypto/Factorization': '#d946ef',
      'Crypto/HeavySet': '#10b981',
      'Crypto/PRF': '#6366f1'
    };

    function hash32(s) {
      let h = 0x811c9dc5;
      for (let i = 0; i < s.length; i++) {
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 0x01000193);
      }
      return h >>> 0;
    }

    function getColor(family) {
      if (colors[family]) return colors[family];
      const h = hash32(family) % 360;
      return `hsl(${h}, 70%, 58%)`;
    }

    function resize() {
      canvas.width = window.innerWidth * devicePixelRatio;
      canvas.height = window.innerHeight * devicePixelRatio;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      ctx.scale(devicePixelRatio, devicePixelRatio);
      render();
    }

    // 3D projection with rotation
    function project3D(x, y, z) {
      // Normalize to [-1, 1]
      const nx = (x - 0.5) * 2;
      const ny = (y - 0.5) * 2;
      const nz = (z - 0.5) * 2;

      // Rotate around Y axis
      const cosY = Math.cos(rotationY);
      const sinY = Math.sin(rotationY);
      const rx = nx * cosY - nz * sinY;
      const rz = nx * sinY + nz * cosY;

      // Rotate around X axis
      const cosX = Math.cos(rotationX);
      const sinX = Math.sin(rotationX);
      const ry = ny * cosX - rz * sinX;
      const finalZ = ny * sinX + rz * cosX;

      // Perspective projection
      const perspective = 3;
      const projScale = perspective / (perspective + finalZ);

      const w = window.innerWidth;
      const h = window.innerHeight;
      const centerX = w / 2;
      const centerY = h / 2;
      const viewScale = Math.min(w, h) * 0.35 * scale;

      return {
        x: centerX + rx * viewScale * projScale,
        y: centerY + ry * viewScale * projScale,
        z: finalZ,
        scale: projScale
      };
    }

    function render() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      ctx.clearRect(0, 0, w, h);

      // Project all points
      const projected = data.items.map(item => {
        // Use z coordinate if available, else derive from position
        const z = item.pos.z !== undefined ? item.pos.z :
                  (hash32(item.name) % 1000) / 1000;
        return {
          ...item,
          proj: project3D(item.pos.x, item.pos.y, z)
        };
      });

      // Sort by z for proper depth ordering
      projected.sort((a, b) => a.proj.z - b.proj.z);

      // Edges
      ctx.lineWidth = 1;
      for (const [i, j] of data.edges) {
        const a = projected.find(p => p.name === data.items[i]?.name);
        const b = projected.find(p => p.name === data.items[j]?.name);
        if (!a || !b) continue;

        const avgZ = (a.proj.z + b.proj.z) / 2;
        const alpha = 0.15 + 0.15 * (1 - (avgZ + 1) / 2);
        ctx.strokeStyle = `rgba(59, 75, 93, ${alpha})`;
        ctx.beginPath();
        ctx.moveTo(a.proj.x, a.proj.y);
        ctx.lineTo(b.proj.x, b.proj.y);
        ctx.stroke();
      }

      // Nodes (back to front)
      for (const item of projected) {
        const p = item.proj;
        const baseR = 5;
        const r = baseR * p.scale * scale;
        const color = getColor(item.family);

        let alpha = 0.5 + 0.5 * (1 - (p.z + 1) / 2);
        if (highlightFamily && item.family !== highlightFamily) alpha *= 0.2;
        if (searchTerm && !item.name.toLowerCase().includes(searchTerm)) alpha *= 0.1;
        if (selectedNode === item.name) alpha = 1;

        ctx.globalAlpha = alpha;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
        ctx.fill();

        // Highlight ring for selected
        if (selectedNode === item.name) {
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(p.x, p.y, r + 3, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
      }
    }

    function buildLegend() {
      const counts = {};
      for (const item of data.items) {
        counts[item.family] = (counts[item.family] || 0) + 1;
      }
      const families = Object.keys(counts).sort((a, b) => counts[b] - counts[a]);

      legend.innerHTML = families.map(f => `
        <div class="legend-item" data-family="${f}">
          <div class="legend-color" style="background: ${getColor(f)}"></div>
          <span>${f} (${counts[f]})</span>
        </div>
      `).join('');

      legend.querySelectorAll('.legend-item').forEach(el => {
        el.addEventListener('click', () => {
          const fam = el.dataset.family;
          highlightFamily = highlightFamily === fam ? null : fam;
          render();
        });
      });
    }

    // Auto-rotation animation
    function animate() {
      if (autoRotating && !isDragging) {
        rotationY += 0.003;
        render();
      }
      requestAnimationFrame(animate);
    }

    // Event handlers
    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const factor = e.deltaY > 0 ? 0.9 : 1.1;
      scale = Math.max(0.3, Math.min(3, scale * factor));
      render();
    });

    canvas.addEventListener('mousedown', e => {
      isDragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
      autoRotating = false;
      autoRotateBtn.classList.remove('active');
    });

    canvas.addEventListener('mousemove', e => {
      if (isDragging) {
        const dx = e.clientX - dragStart.x;
        const dy = e.clientY - dragStart.y;
        rotationY += dx * 0.005;
        rotationX += dy * 0.005;
        rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));
        dragStart = { x: e.clientX, y: e.clientY };
        render();
      }

      // Tooltip
      const projected = data.items.map(item => {
        const z = item.pos.z !== undefined ? item.pos.z :
                  (hash32(item.name) % 1000) / 1000;
        return {
          ...item,
          proj: project3D(item.pos.x, item.pos.y, z)
        };
      });

      let found = null;
      let minDist = Infinity;
      for (const item of projected) {
        const dx = e.clientX - item.proj.x;
        const dy = e.clientY - item.proj.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 15 * scale && dist < minDist) {
          found = item;
          minDist = dist;
        }
      }

      if (found) {
        tooltip.innerHTML = `<div class="name">${found.name}</div><div class="kind">${found.kind} â€¢ ${found.family}</div>`;
        tooltip.style.display = 'block';
        tooltip.style.left = (e.clientX + 15) + 'px';
        tooltip.style.top = (e.clientY + 15) + 'px';
      } else {
        tooltip.style.display = 'none';
      }
    });

    canvas.addEventListener('mouseup', () => isDragging = false);
    canvas.addEventListener('mouseleave', () => isDragging = false);

    canvas.addEventListener('click', e => {
      const projected = data.items.map(item => {
        const z = item.pos.z !== undefined ? item.pos.z :
                  (hash32(item.name) % 1000) / 1000;
        return {
          ...item,
          proj: project3D(item.pos.x, item.pos.y, z)
        };
      });

      let found = null;
      let minDist = Infinity;
      for (const item of projected) {
        const dx = e.clientX - item.proj.x;
        const dy = e.clientY - item.proj.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 15 * scale && dist < minDist) {
          found = item;
          minDist = dist;
        }
      }

      selectedNode = found ? found.name : null;
      render();
    });

    search.addEventListener('input', e => {
      searchTerm = e.target.value.toLowerCase();
      render();
    });

    autoRotateBtn.addEventListener('click', () => {
      autoRotating = !autoRotating;
      autoRotateBtn.classList.toggle('active', autoRotating);
    });

    resetViewBtn.addEventListener('click', () => {
      rotationX = 0.3;
      rotationY = 0.5;
      scale = 1;
      selectedNode = null;
      render();
    });

    window.addEventListener('resize', resize);

    // Initialize
    buildLegend();
    autoRotateBtn.classList.add('active');
    resize();
    animate();
  </script>
</body>
</html>
